<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 7 - 物件導向程式設計（下）| Python 程式設計</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(to bottom, #f5f7fa 0%, #c3cfe2 100%);
            color: #2c3e50;
            line-height: 1.7;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        .nav {
            background: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .nav a {
            color: #3776ab;
            text-decoration: none;
            font-weight: 600;
            padding: 8px 16px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .nav a:hover {
            background: #3776ab;
            color: white;
        }

        header {
            background: linear-gradient(135deg, #3776ab 0%, #ffd343 100%);
            color: white;
            padding: 50px 40px;
            border-radius: 8px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            background: white;
            border-radius: 8px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .content h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3776ab;
        }

        .content h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 30px 0 15px 0;
        }

        .content h4 {
            color: #34495e;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        pre[class*="language-"] {
            margin: 20px 0;
            border-radius: 8px;
            border: 2px solid #3776ab;
        }

        code[class*="language-"] {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
        }

        .note-box {
            background: #e8f4f8;
            border-left: 4px solid #3776ab;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff8e1;
            border-left: 4px solid #ffa726;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .tip-box {
            background: #e8f5e9;
            border-left: 4px solid #66bb6a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .exercise-section {
            background: #f8f9fa;
            border: 2px solid #3776ab;
            padding: 30px;
            margin: 30px 0;
            border-radius: 8px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table th,
        table td {
            padding: 12px;
            text-align: left;
            border: 1px solid #ddd;
        }

        table th {
            background: #3776ab;
            color: white;
            font-weight: 600;
        }

        table tr:nth-child(even) {
            background: #f8f9fa;
        }

        ul, ol {
            margin-left: 30px;
            margin-top: 10px;
        }

        li {
            margin: 8px 0;
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }

        .btn {
            display: inline-block;
            padding: 12px 30px;
            background: #3776ab;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: #2d5a8a;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .concept-box {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav">
            <a href="week6.html">← Week 6</a>
            <span style="color: #7f8c8d; font-weight: 600;">Week 7 / 16</span>
            <a href="week8.html">Week 8 →</a>
        </div>

        <header>
            <h1>Week 7 - 物件導向程式設計（下）</h1>
            <div class="subtitle">學習目標：掌握繼承、多型、抽象類別等進階 OOP 概念</div>
        </header>

        <div class="content">
            <h2>本週學習內容</h2>
            <ul>
                <li>繼承（Inheritance）基礎</li>
                <li>方法覆寫（Method Overriding）</li>
                <li>super() 函數</li>
                <li>多重繼承</li>
                <li>多型（Polymorphism）</li>
                <li>抽象類別與介面</li>
                <li>組合 vs 繼承</li>
                <li>設計模式入門</li>
                <li>實戰專案範例</li>
            </ul>
        </div>

        <div class="content">
            <h2>1. 繼承（Inheritance）</h2>
            
            <h3>什麼是繼承？</h3>
            <p>繼承允許我們建立一個新類別（子類別）來繼承現有類別（父類別）的屬性和方法，並且可以添加新的功能或修改現有功能。</p>

            <div class="concept-box">
                <h4>繼承的優點：</h4>
                <ul>
                    <li><strong>程式碼重用</strong>：避免重複撰寫相同的程式碼</li>
                    <li><strong>層次結構</strong>：建立清晰的類別關係</li>
                    <li><strong>擴展性</strong>：容易添加新功能</li>
                    <li><strong>多型</strong>：實現多型的基礎</li>
                </ul>
            </div>

            <h3>基本繼承</h3>
            <pre><code class="language-python"># 父類別（基底類別、超類別）
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def make_sound(self):
        print(f"{self.name} 發出聲音")
    
    def info(self):
        print(f"{self.name} 今年 {self.age} 歲")


# 子類別（衍生類別）
class Dog(Animal):  # 繼承 Animal
    def make_sound(self):
        print(f"{self.name} 說：汪汪汪！")


class Cat(Animal):  # 繼承 Animal
    def make_sound(self):
        print(f"{self.name} 說：喵喵喵！")


# 使用範例
dog = Dog("小黃", 3)
cat = Cat("小白", 2)

dog.info()        # 小黃 今年 3 歲（繼承自 Animal）
dog.make_sound()  # 小黃 說：汪汪汪！（覆寫）

cat.info()        # 小白 今年 2 歲
cat.make_sound()  # 小白 說：喵喵喵！
</code></pre>

            <h3>添加新屬性和方法</h3>
            <pre><code class="language-python">class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def info(self):
        print(f"{self.name} 今年 {self.age} 歲")


class Dog(Animal):
    def __init__(self, name, age, breed):
        # 呼叫父類別的建構子
        super().__init__(name, age)
        # 添加新屬性
        self.breed = breed
    
    def bark(self):
        """子類別特有的方法"""
        print(f"{self.name} 汪汪叫！")
    
    def info(self):
        """覆寫父類別的方法"""
        super().info()  # 呼叫父類別的 info
        print(f"品種：{self.breed}")


# 使用範例
dog = Dog("小黃", 3, "黃金獵犬")
dog.info()
# 輸出：
# 小黃 今年 3 歲
# 品種：黃金獵犬

dog.bark()  # 小黃 汪汪叫！
</code></pre>

            <h3>檢查繼承關係</h3>
            <pre><code class="language-python">class Animal:
    pass

class Dog(Animal):
    pass

class Cat(Animal):
    pass

dog = Dog()
cat = Cat()

# isinstance() - 檢查物件是否為某類別的實例
print(isinstance(dog, Dog))     # True
print(isinstance(dog, Animal))  # True（Dog 繼承 Animal）
print(isinstance(dog, Cat))     # False

# issubclass() - 檢查類別繼承關係
print(issubclass(Dog, Animal))  # True
print(issubclass(Dog, Cat))     # False
print(issubclass(Dog, Dog))     # True

# type() - 取得物件的確切類別
print(type(dog))  # <class '__main__.Dog'>
print(type(dog) == Dog)     # True
print(type(dog) == Animal)  # False
</code></pre>

            <h3>完整範例：員工管理系統</h3>
            <pre><code class="language-python">class Employee:
    """員工基礎類別"""
    
    def __init__(self, name, employee_id, salary):
        self.name = name
        self.employee_id = employee_id
        self.salary = salary
    
    def get_info(self):
        """取得員工資訊"""
        return f"員工：{self.name}（{self.employee_id}），薪資：${self.salary}"
    
    def calculate_bonus(self):
        """計算獎金（基本獎金）"""
        return self.salary * 0.1


class Manager(Employee):
    """經理類別"""
    
    def __init__(self, name, employee_id, salary, department):
        super().__init__(name, employee_id, salary)
        self.department = department
    
    def get_info(self):
        """覆寫：添加部門資訊"""
        base_info = super().get_info()
        return f"{base_info}，部門：{self.department}"
    
    def calculate_bonus(self):
        """覆寫：經理獎金較高"""
        return self.salary * 0.2


class Developer(Employee):
    """開發者類別"""
    
    def __init__(self, name, employee_id, salary, programming_language):
        super().__init__(name, employee_id, salary)
        self.programming_language = programming_language
    
    def get_info(self):
        """覆寫：添加程式語言"""
        base_info = super().get_info()
        return f"{base_info}，語言：{self.programming_language}"
    
    def code(self):
        """開發者特有方法"""
        print(f"{self.name} 正在用 {self.programming_language} 寫程式")


# 使用範例
employees = [
    Manager("Alice", "M001", 80000, "業務部"),
    Developer("Bob", "D001", 70000, "Python"),
    Developer("Charlie", "D002", 75000, "Java"),
]

for emp in employees:
    print(emp.get_info())
    print(f"獎金：${emp.calculate_bonus()}")
    print()

# Developer 特有方法
employees[1].code()  # Bob 正在用 Python 寫程式
</code></pre>
        </div>

        <div class="content">
            <h2>2. super() 函數</h2>
            
            <h3>super() 的用途</h3>
            <pre><code class="language-python"># super() 用於呼叫父類別的方法

class Parent:
    def __init__(self, name):
        self.name = name
        print(f"Parent 建構子：{name}")
    
    def greet(self):
        print(f"Parent: Hello, {self.name}")


class Child(Parent):
    def __init__(self, name, age):
        # 呼叫父類別的建構子
        super().__init__(name)
        self.age = age
        print(f"Child 建構子：{age}")
    
    def greet(self):
        # 呼叫父類別的方法
        super().greet()
        print(f"Child: I'm {self.age} years old")


# 使用範例
child = Child("Alice", 10)
# 輸出：
# Parent 建構子：Alice
# Child 建構子：10

child.greet()
# 輸出：
# Parent: Hello, Alice
# Child: I'm 10 years old
</code></pre>

            <h3>不使用 super() 的問題</h3>
            <pre><code class="language-python"># 不推薦的寫法
class Child(Parent):
    def __init__(self, name, age):
        Parent.__init__(self, name)  # 硬編碼父類別名稱
        self.age = age

# 問題：
# 1. 如果改變父類別名稱，需要修改所有子類別
# 2. 在多重繼承時可能出問題
# 3. 不符合 DRY 原則


# 推薦使用 super()
class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)  # 動態解析父類別
        self.age = age
</code></pre>

            <h3>super() 在方法鏈中的應用</h3>
            <pre><code class="language-python">class A:
    def process(self):
        print("A 處理")


class B(A):
    def process(self):
        print("B 開始處理")
        super().process()  # 呼叫 A.process()
        print("B 結束處理")


class C(B):
    def process(self):
        print("C 開始處理")
        super().process()  # 呼叫 B.process()
        print("C 結束處理")


# 使用範例
c = C()
c.process()

# 輸出：
# C 開始處理
# B 開始處理
# A 處理
# B 結束處理
# C 結束處理
</code></pre>
        </div>

        <div class="content">
            <h2>3. 多重繼承</h2>
            
            <h3>基本多重繼承</h3>
            <pre><code class="language-python"># Python 支援多重繼承（繼承多個父類別）

class Flyer:
    """會飛的能力"""
    def fly(self):
        print("我會飛！")


class Swimmer:
    """會游泳的能力"""
    def swim(self):
        print("我會游泳！")


class Duck(Flyer, Swimmer):
    """鴨子：既會飛又會游泳"""
    def quack(self):
        print("嘎嘎嘎！")


# 使用範例
duck = Duck()
duck.fly()    # 我會飛！
duck.swim()   # 我會游泳！
duck.quack()  # 嘎嘎嘎！
</code></pre>

            <h3>方法解析順序（MRO）</h3>
            <pre><code class="language-python">class A:
    def method(self):
        print("A 的方法")


class B(A):
    def method(self):
        print("B 的方法")


class C(A):
    def method(self):
        print("C 的方法")


class D(B, C):
    pass


# 查看 MRO（Method Resolution Order）
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, 
#  <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

# 或使用 mro() 方法
print(D.mro())

# 呼叫方法
d = D()
d.method()  # B 的方法（根據 MRO，先找到 B）
</code></pre>

            <h3>鑽石繼承問題</h3>
            <pre><code class="language-python">class Animal:
    def __init__(self, name):
        print(f"Animal.__init__({name})")
        self.name = name


class Mammal(Animal):
    def __init__(self, name):
        print("Mammal.__init__")
        super().__init__(name)


class Bird(Animal):
    def __init__(self, name):
        print("Bird.__init__")
        super().__init__(name)


class Bat(Mammal, Bird):
    def __init__(self, name):
        print("Bat.__init__")
        super().__init__(name)


# 使用範例
bat = Bat("蝙蝠俠")

# 輸出：
# Bat.__init__
# Mammal.__init__
# Bird.__init__
# Animal.__init__(蝙蝠俠)

# MRO 確保 Animal.__init__ 只被呼叫一次
print(Bat.__mro__)
</code></pre>

            <div class="warning-box">
                <strong>多重繼承注意事項：</strong>
                <ul>
                    <li>謹慎使用多重繼承，可能導致複雜性增加</li>
                    <li>注意方法解析順序（MRO）</li>
                    <li>考慮使用組合（Composition）替代</li>
                    <li>確保所有父類別都正確使用 super()</li>
                    <li>避免鑽石繼承問題</li>
                </ul>
            </div>

            <h3>Mixin 設計模式</h3>
            <pre><code class="language-python"># Mixin：提供額外功能的小型類別

class JSONMixin:
    """提供 JSON 序列化功能"""
    def to_json(self):
        import json
        return json.dumps(self.__dict__)


class LogMixin:
    """提供日誌記錄功能"""
    def log(self, message):
        print(f"[{self.__class__.__name__}] {message}")


class User(JSONMixin, LogMixin):
    """使用者類別：混入 JSON 和日誌功能"""
    def __init__(self, name, email):
        self.name = name
        self.email = email


# 使用範例
user = User("Alice", "alice@example.com")

# 使用 JSONMixin 的功能
print(user.to_json())
# {"name": "Alice", "email": "alice@example.com"}

# 使用 LogMixin 的功能
user.log("使用者已建立")
# [User] 使用者已建立
</code></pre>
        </div>

        <div class="content">
            <h2>4. 多型（Polymorphism）</h2>
            
            <h3>什麼是多型？</h3>
            <p>多型允許不同類別的物件對相同的方法做出不同的回應。</p>

            <h3>方法多型</h3>
            <pre><code class="language-python">class Shape:
    """形狀基礎類別"""
    def area(self):
        pass
    
    def perimeter(self):
        pass


class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)


class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        import math
        return 2 * math.pi * self.radius


class Triangle(Shape):
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
    
    def area(self):
        # 海龍公式
        s = self.perimeter() / 2
        return (s * (s - self.a) * (s - self.b) * (s - self.c)) ** 0.5
    
    def perimeter(self):
        return self.a + self.b + self.c


# 多型的威力：相同的介面，不同的實作
shapes = [
    Rectangle(5, 10),
    Circle(7),
    Triangle(3, 4, 5)
]

for shape in shapes:
    print(f"{shape.__class__.__name__}:")
    print(f"  面積: {shape.area():.2f}")
    print(f"  周長: {shape.perimeter():.2f}")
    print()
</code></pre>

            <h3>運算符多型</h3>
            <pre><code class="language-python">class Money:
    """貨幣類別"""
    
    def __init__(self, amount, currency="TWD"):
        self.amount = amount
        self.currency = currency
    
    def __str__(self):
        return f"{self.amount} {self.currency}"
    
    def __add__(self, other):
        """加法"""
        if self.currency != other.currency:
            raise ValueError("貨幣類型不同，無法相加")
        return Money(self.amount + other.amount, self.currency)
    
    def __sub__(self, other):
        """減法"""
        if self.currency != other.currency:
            raise ValueError("貨幣類型不同，無法相減")
        return Money(self.amount - other.amount, self.currency)
    
    def __mul__(self, multiplier):
        """乘法"""
        return Money(self.amount * multiplier, self.currency)
    
    def __eq__(self, other):
        """相等比較"""
        return (self.amount == other.amount and 
                self.currency == other.currency)


# 使用範例
money1 = Money(100)
money2 = Money(50)

print(money1 + money2)  # 150 TWD
print(money1 - money2)  # 50 TWD
print(money1 * 2)       # 200 TWD
print(money1 == money2) # False
</code></pre>

            <h3>Duck Typing</h3>
            <pre><code class="language-python"># Python 的 Duck Typing：
# "如果它走起來像鴨子，叫起來像鴨子，那它就是鴨子"

class Dog:
    def speak(self):
        return "汪汪汪"


class Cat:
    def speak(self):
        return "喵喵喵"


class Duck:
    def speak(self):
        return "嘎嘎嘎"


# 不需要繼承關係，只要有 speak 方法即可
def make_it_speak(animal):
    """讓動物說話（多型）"""
    print(animal.speak())


# 使用範例
animals = [Dog(), Cat(), Duck()]

for animal in animals:
    make_it_speak(animal)

# 輸出：
# 汪汪汪
# 喵喵喵
# 嘎嘎嘎
</code></pre>
        </div>

        <div class="content">
            <h2>5. 抽象類別與介面</h2>
            
            <h3>抽象類別</h3>
            <pre><code class="language-python">from abc import ABC, abstractmethod

class Animal(ABC):
    """抽象類別：無法直接實例化"""
    
    def __init__(self, name):
        self.name = name
    
    @abstractmethod
    def make_sound(self):
        """抽象方法：子類別必須實作"""
        pass
    
    @abstractmethod
    def move(self):
        """抽象方法：子類別必須實作"""
        pass
    
    def sleep(self):
        """具體方法：子類別可以直接使用"""
        print(f"{self.name} 正在睡覺")


# 錯誤：無法實例化抽象類別
# animal = Animal("動物")  # TypeError


class Dog(Animal):
    """具體類別：實作所有抽象方法"""
    
    def make_sound(self):
        print(f"{self.name} 說：汪汪汪！")
    
    def move(self):
        print(f"{self.name} 在奔跑")


class Bird(Animal):
    """具體類別：實作所有抽象方法"""
    
    def make_sound(self):
        print(f"{self.name} 說：啾啾啾！")
    
    def move(self):
        print(f"{self.name} 在飛翔")


# 使用範例
dog = Dog("小黃")
bird = Bird("小鳥")

dog.make_sound()  # 小黃 說：汪汪汪！
dog.move()        # 小黃 在奔跑
dog.sleep()       # 小黃 正在睡覺

bird.make_sound() # 小鳥 說：啾啾啾！
bird.move()       # 小鳥 在飛翔
</code></pre>

            <h3>介面（Interface）</h3>
            <pre><code class="language-python"># Python 沒有明確的介面概念，但可以用抽象類別模擬

from abc import ABC, abstractmethod

class Drawable(ABC):
    """可繪製介面"""
    
    @abstractmethod
    def draw(self):
        pass


class Resizable(ABC):
    """可調整大小介面"""
    
    @abstractmethod
    def resize(self, width, height):
        pass


class Rectangle(Drawable, Resizable):
    """矩形：實作多個介面"""
    
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    
    def draw(self):
        print(f"繪製矩形於 ({self.x}, {self.y})，"
              f"大小 {self.width}x{self.height}")
    
    def resize(self, width, height):
        self.width = width
        self.height = height
        print(f"調整大小為 {width}x{height}")


# 使用範例
rect = Rectangle(10, 20, 100, 50)
rect.draw()           # 繪製矩形於 (10, 20)，大小 100x50
rect.resize(150, 75)  # 調整大小為 150x75
rect.draw()           # 繪製矩形於 (10, 20)，大小 150x75
</code></pre>

            <h3>實用範例：支付系統</h3>
            <pre><code class="language-python">from abc import ABC, abstractmethod

class PaymentMethod(ABC):
    """支付方式抽象類別"""
    
    @abstractmethod
    def pay(self, amount):
        """執行支付"""
        pass
    
    @abstractmethod
    def refund(self, amount):
        """執行退款"""
        pass


class CreditCard(PaymentMethod):
    """信用卡支付"""
    
    def __init__(self, card_number, cvv):
        self.card_number = card_number
        self.cvv = cvv
    
    def pay(self, amount):
        print(f"使用信用卡 {self.card_number[-4:]} 支付 ${amount}")
        # 實際支付邏輯
        return True
    
    def refund(self, amount):
        print(f"退款 ${amount} 至信用卡 {self.card_number[-4:]}")
        return True


class PayPal(PaymentMethod):
    """PayPal 支付"""
    
    def __init__(self, email):
        self.email = email
    
    def pay(self, amount):
        print(f"使用 PayPal ({self.email}) 支付 ${amount}")
        return True
    
    def refund(self, amount):
        print(f"退款 ${amount} 至 PayPal ({self.email})")
        return True


class BankTransfer(PaymentMethod):
    """銀行轉帳"""
    
    def __init__(self, account_number):
        self.account_number = account_number
    
    def pay(self, amount):
        print(f"從帳戶 {self.account_number} 轉帳 ${amount}")
        return True
    
    def refund(self, amount):
        print(f"退款 ${amount} 至帳戶 {self.account_number}")
        return True


# 購物車系統
class ShoppingCart:
    def __init__(self):
        self.total = 0
    
    def checkout(self, payment_method: PaymentMethod):
        """結帳（使用任何支付方式）"""
        if self.total > 0:
            payment_method.pay(self.total)
            print("支付成功！")
        else:
            print("購物車是空的")


# 使用範例
cart = ShoppingCart()
cart.total = 1500

# 使用不同的支付方式（多型）
credit_card = CreditCard("1234-5678-9012-3456", "123")
paypal = PayPal("user@example.com")
bank = BankTransfer("987-654-321")

cart.checkout(credit_card)  # 使用信用卡
cart.checkout(paypal)       # 使用 PayPal
cart.checkout(bank)         # 使用銀行轉帳
</code></pre>
        </div>

        <div class="content">
            <h2>6. 組合 vs 繼承</h2>
            
            <h3>繼承的問題</h3>
            <pre><code class="language-python"># 繼承可能導致緊密耦合

class Vehicle:
    def start_engine(self):
        print("引擎啟動")


class Car(Vehicle):
    pass


class Bicycle(Vehicle):  # 問題：自行車沒有引擎！
    pass
</code></pre>

            <h3>使用組合（Composition）</h3>
            <pre><code class="language-python"># 組合：使用「有一個」（has-a）關係，而非「是一個」（is-a）

class Engine:
    """引擎類別"""
    def start(self):
        print("引擎啟動")
    
    def stop(self):
        print("引擎熄火")


class Wheel:
    """輪子類別"""
    def __init__(self, size):
        self.size = size


class Car:
    """汽車：組合引擎和輪子"""
    def __init__(self):
        self.engine = Engine()  # 組合
        self.wheels = [Wheel(17) for _ in range(4)]  # 組合
    
    def start(self):
        print("汽車啟動")
        self.engine.start()
    
    def stop(self):
        print("汽車停止")
        self.engine.stop()


class Bicycle:
    """自行車：只有輪子，沒有引擎"""
    def __init__(self):
        self.wheels = [Wheel(26) for _ in range(2)]
    
    def pedal(self):
        print("踩踏板前進")


# 使用範例
car = Car()
car.start()  # 汽車啟動 / 引擎啟動

bicycle = Bicycle()
bicycle.pedal()  # 踩踏板前進
</code></pre>

            <h3>繼承 vs 組合的選擇</h3>
            <table>
                <tr>
                    <th>考量點</th>
                    <th>繼承（Inheritance）</th>
                    <th>組合（Composition）</th>
                </tr>
                <tr>
                    <td>關係</td>
                    <td>「是一個」（is-a）</td>
                    <td>「有一個」（has-a）</td>
                </tr>
                <tr>
                    <td>耦合度</td>
                    <td>高（緊密耦合）</td>
                    <td>低（鬆散耦合）</td>
                </tr>
                <tr>
                    <td>靈活性</td>
                    <td>較低</td>
                    <td>較高</td>
                </tr>
                <tr>
                    <td>程式碼重用</td>
                    <td>自動繼承</td>
                    <td>需要委派</td>
                </tr>
                <tr>
                    <td>適用情境</td>
                    <td>清晰的層次關係</td>
                    <td>需要靈活組合功能</td>
                </tr>
            </table>

            <div class="tip-box">
                <strong>設計原則：</strong>
                <ul>
                    <li><strong>優先使用組合</strong>：「Favor composition over inheritance」</li>
                    <li>繼承適合「是一個」關係</li>
                    <li>組合適合「有一個」關係</li>
                    <li>當不確定時，選擇組合</li>
                    <li>避免深層繼承（超過 3-4 層）</li>
                </ul>
            </div>

            <h3>實用範例：遊戲角色系統</h3>
            <pre><code class="language-python"># 使用組合設計靈活的角色系統

class Weapon:
    """武器類別"""
    def __init__(self, name, damage):
        self.name = name
        self.damage = damage
    
    def attack(self):
        return self.damage


class Armor:
    """護甲類別"""
    def __init__(self, name, defense):
        self.name = name
        self.defense = defense
    
    def protect(self):
        return self.defense


class Skill:
    """技能類別"""
    def __init__(self, name, effect):
        self.name = name
        self.effect = effect
    
    def use(self):
        print(f"使用技能：{self.name}（{self.effect}）")


class Character:
    """角色類別（使用組合）"""
    
    def __init__(self, name, hp):
        self.name = name
        self.hp = hp
        self.weapon = None
        self.armor = None
        self.skills = []
    
    def equip_weapon(self, weapon):
        """裝備武器"""
        self.weapon = weapon
        print(f"{self.name} 裝備了 {weapon.name}")
    
    def equip_armor(self, armor):
        """裝備護甲"""
        self.armor = armor
        print(f"{self.name} 穿上了 {armor.name}")
    
    def learn_skill(self, skill):
        """學習技能"""
        self.skills.append(skill)
        print(f"{self.name} 學會了 {skill.name}")
    
    def attack(self, target):
        """攻擊"""
        if self.weapon:
            damage = self.weapon.attack()
            if target.armor:
                damage -= target.armor.protect()
                damage = max(0, damage)
            
            target.hp -= damage
            print(f"{self.name} 攻擊 {target.name}，"
                  f"造成 {damage} 點傷害")
        else:
            print(f"{self.name} 沒有武器！")


# 使用範例
hero = Character("勇者", 100)
enemy = Character("哥布林", 50)

# 裝備武器和護甲
sword = Weapon("長劍", 30)
shield = Armor("盾牌", 10)

hero.equip_weapon(sword)
hero.equip_armor(shield)

# 學習技能
fireball = Skill("火球術", "造成 50 點魔法傷害")
hero.learn_skill(fireball)

# 戰鬥
hero.attack(enemy)
hero.skills[0].use()
</code></pre>
        </div>

        <div class="content">
            <h2>7. 設計模式入門</h2>
            
            <h3>單例模式（Singleton）</h3>
            <pre><code class="language-python">class Singleton:
    """單例模式：確保類別只有一個實例"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance


# 使用範例
s1 = Singleton()
s2 = Singleton()

print(s1 is s2)  # True（同一個實例）


# 實用範例：資料庫連線
class Database:
    """資料庫連線（單例）"""
    
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.connection = None
        return cls._instance
    
    def connect(self):
        if self.connection is None:
            print("建立資料庫連線")
            self.connection = "Connected"
        else:
            print("使用現有連線")
    
    def query(self, sql):
        print(f"執行查詢：{sql}")


# 使用範例
db1 = Database()
db1.connect()  # 建立資料庫連線

db2 = Database()
db2.connect()  # 使用現有連線

print(db1 is db2)  # True
</code></pre>

            <h3>工廠模式（Factory）</h3>
            <pre><code class="language-python">from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass


class Dog(Animal):
    def speak(self):
        return "汪汪汪"


class Cat(Animal):
    def speak(self):
        return "喵喵喵"


class AnimalFactory:
    """動物工廠：根據類型建立物件"""
    
    @staticmethod
    def create_animal(animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            raise ValueError(f"未知的動物類型：{animal_type}")


# 使用範例
factory = AnimalFactory()

dog = factory.create_animal("dog")
cat = factory.create_animal("cat")

print(dog.speak())  # 汪汪汪
print(cat.speak())  # 喵喵喵
</code></pre>

            <h3>觀察者模式（Observer）</h3>
            <pre><code class="language-python">class Subject:
    """主題（被觀察者）"""
    
    def __init__(self):
        self._observers = []
        self._state = None
    
    def attach(self, observer):
        """註冊觀察者"""
        self._observers.append(observer)
    
    def detach(self, observer):
        """移除觀察者"""
        self._observers.remove(observer)
    
    def notify(self):
        """通知所有觀察者"""
        for observer in self._observers:
            observer.update(self._state)
    
    def set_state(self, state):
        """設定狀態並通知觀察者"""
        print(f"狀態改變：{state}")
        self._state = state
        self.notify()


class Observer:
    """觀察者"""
    
    def __init__(self, name):
        self.name = name
    
    def update(self, state):
        """收到通知時的動作"""
        print(f"{self.name} 收到通知：{state}")


# 使用範例
subject = Subject()

observer1 = Observer("觀察者1")
observer2 = Observer("觀察者2")
observer3 = Observer("觀察者3")

# 註冊觀察者
subject.attach(observer1)
subject.attach(observer2)
subject.attach(observer3)

# 改變狀態（會通知所有觀察者）
subject.set_state("新訊息到達")
subject.set_state("系統更新")

# 移除觀察者
subject.detach(observer2)
subject.set_state("再次更新")
</code></pre>
        </div>

        <div class="content">
            <div class="exercise-section">
                <h3>本週練習題</h3>
                
                <h4>基礎練習（必做）</h4>
                <ol>
                    <li>
                        <strong>交通工具繼承</strong><br>
                        建立類別架構：
                        <ul>
                            <li>Vehicle 基礎類別（brand、speed）</li>
                            <li>Car 繼承 Vehicle（添加 fuel_type）</li>
                            <li>Motorcycle 繼承 Vehicle（添加 engine_cc）</li>
                            <li>實作各自的 show_info() 方法</li>
                        </ul>
                    </li>
                    
                    <li>
                        <strong>形狀計算器</strong><br>
                        使用抽象類別：
                        <ul>
                            <li>Shape 抽象類別（area、perimeter 抽象方法）</li>
                            <li>實作 Square、Circle、Triangle</li>
                            <li>建立形狀列表並計算總面積</li>
                        </ul>
                    </li>
                    
                    <li>
                        <strong>動物園系統</strong><br>
                        練習多型：
                        <ul>
                            <li>Animal 基礎類別</li>
                            <li>Lion、Elephant、Monkey 子類別</li>
                            <li>每種動物有不同的 make_sound() 和 move()</li>
                            <li>建立動物列表並遍歷展示</li>
                        </ul>
                    </li>
                </ol>

                <h4>進階練習</h4>
                <ol start="4">
                    <li>
                        <strong>員工薪資系統</strong><br>
                        建立完整的員工管理：
                        <ul>
                            <li>Employee 基礎類別</li>
                            <li>FullTimeEmployee、PartTimeEmployee、Contractor</li>
                            <li>不同員工類型有不同的薪資計算方式</li>
                            <li>實作年度獎金計算</li>
                        </ul>
                    </li>
                    
                    <li>
                        <strong>媒體播放器</strong><br>
                        使用組合設計：
                        <ul>
                            <li>Media 類別（音樂、影片）</li>
                            <li>Playlist 類別（管理媒體清單）</li>
                            <li>Player 類別（播放、暫停、下一首）</li>
                            <li>實作播放記錄功能</li>
                        </ul>
                    </li>
                    
                    <li>
                        <strong>訂單處理系統</strong><br>
                        練習抽象類別：
                        <ul>
                            <li>OrderProcessor 抽象類別</li>
                            <li>OnlineOrder、StoreOrder 實作類別</li>
                            <li>不同訂單有不同的處理流程</li>
                            <li>實作訂單狀態追蹤</li>
                        </ul>
                    </li>
                </ol>

                <h4>挑戰練習</h4>
                <ol start="7">
                    <li>
                        <strong>RPG 遊戲系統</strong><br>
                        完整的角色扮演遊戲：
                        <ul>
                            <li>Character 基礎類別</li>
                            <li>Warrior、Mage、Archer 職業</li>
                            <li>使用組合實作裝備系統</li>
                            <li>技能系統、戰鬥系統</li>
                            <li>經驗值與升級機制</li>
                        </ul>
                    </li>
                    
                    <li>
                        <strong>電商平台</strong><br>
                        建立完整系統：
                        <ul>
                            <li>Product 類別層次（實體商品、數位商品）</li>
                            <li>User、Seller、Buyer 角色</li>
                            <li>訂單處理（使用工廠模式）</li>
                            <li>支付系統（使用策略模式）</li>
                            <li>通知系統（使用觀察者模式）</li>
                        </ul>
                    </li>
                    
                    <li>
                        <strong>社群平台</strong><br>
                        設計社群媒體系統：
                        <ul>
                            <li>User、Post、Comment 類別</li>
                            <li>使用組合建立朋友關係</li>
                            <li>貼文的讚、分享功能</li>
                            <li>通知系統（觀察者模式）</li>
                            <li>隱私設定與權限控制</li>
                        </ul>
                    </li>
                </ol>

                <div class="tip-box">
                    <strong>練習提示：</strong>
                    <ul>
                        <li>先畫出類別關係圖</li>
                        <li>思考「是一個」vs「有一個」關係</li>
                        <li>優先考慮組合而非繼承</li>
                        <li>使用抽象類別定義介面</li>
                        <li>注意避免過深的繼承層次</li>
                        <li>適時應用設計模式</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="content">
            <h2>本週總結</h2>
            
            <h3>重點回顧</h3>
            <ul>
                <li>✅ 掌握繼承的概念與實作</li>
                <li>✅ 理解 super() 的用法</li>
                <li>✅ 了解多重繼承與 MRO</li>
                <li>✅ 熟悉多型的應用</li>
                <li>✅ 學會使用抽象類別</li>
                <li>✅ 理解組合 vs 繼承的選擇</li>
                <li>✅ 認識基本設計模式</li>
                <li>✅ 能夠設計複雜的類別系統</li>
            </ul>

            <h3>下週預告</h3>
            <div class="note-box">
                <h4>Week 8 - 正規表達式與字串處理</h4>
                <p>下週將學習強大的文字處理工具：</p>
                <ul>
                    <li>正規表達式基礎語法</li>
                    <li>re 模組的使用</li>
                    <li>常用模式與範例</li>
                    <li>字串進階操作</li>
                    <li>文字解析與驗證</li>
                    <li>實用的文字處理技巧</li>
                    <li>網頁爬蟲入門</li>
                </ul>
            </div>
        </div>

        <div class="nav-buttons">
            <a href="week6.html" class="btn btn-secondary">← Week 6</a>
            <a href="week8-part1.html" class="btn">Week 8：正規表達式 →</a>
        </div>

        <footer style="text-align: center; padding: 30px 0; color: #7f8c8d; margin-top: 50px; border-top: 1px solid #ddd;">
            <p style="margin: 10px 0;">Python 程式設計 Week 7</p>
            <p style="margin: 10px 0; font-size: 0.9em;">繼承 · 多型 · 抽象類別 · 設計模式</p>
            <p style="margin: 10px 0; font-size: 0.85em; color: #95a5a6;">© 2025 All Rights Reserved</p>
        </footer>
    </div>
</body>
</html>